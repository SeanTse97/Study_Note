# JVM学习笔记

### 一、JAVA 虚拟机内存模型

#### 1.1 通用模型图：

![](D:\桌面\编程学习\Java\JVM\images\内存模型通用图.PNG)



#### 1.2 内存区域划分图：

![](D:\桌面\编程学习\Java\JVM\images\内存区域划分.jpg)



#### 1.3 较为细致的图：

![](D:\桌面\编程学习\Java\JVM\images\内存区域分布图.PNG)



#### 1.4 JVM执行过程图：

![](D:\桌面\编程学习\Java\JVM\images\JVM执行过程.PNG)

#### 1.5 从线程角度的运行时内存结构图：

 ![](D:\桌面\编程学习\Java\JVM\images\线程角度运行时数据区.png)



#### 1.6 《java虚拟机规范》规定，JVM的基本结构一般如下图所示：

![](D:\桌面\编程学习\Java\JVM\images\JVM的基本结构图.jpg)



### 二、基本分区介绍：

(1) **程序计数器**：当前线程所执行的字节码的行号指示器，内存空间小，线程私有。

 内存溢出情况：唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

(2) **虚拟机栈**：描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。线程私有，生命周期和线程一致。

**局部变量表：**存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)。

内存溢出情况：StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。

​            OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。


(3) **本地方法栈**：本地方法栈是为虚拟机使用到的Native方法服务。在Hotspot虚拟机中本地方法栈与虚拟机栈中合二为一。

内存溢出情况： StackOverflowError 和 OutOfMemoryError 异常。


(4) **堆**：存放对象实例和数组，几乎所有的对象实例都在这里分配内存。

内存溢出情况：OutOfMemoryError


(5) **方法区**：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。(元空间)

**运行时常量池**：是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有
常量池用于存放编译期间生成的各种字面量和符号引用。

(6) **元数据区**

从1.8开始，元数据区取代了1.7的永久代，作用是存放虚拟机加载的类信息、静态变量，常量等

(7)  **直接内存**

java 1.4 的NIO库允许java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。

**简单描述：**

**堆**：存放对象的实例以及对象的属性和方法

**栈**：储存基本数据类型的值、执行的方法、方法中声明的变量、数组、对象的引用(reference类型)

**方法区**：存储已被虚拟机加载的类元数据信息(元空间)

**运行时常量池**：常量(final)、字符串

 

 ![img](https://img2018.cnblogs.com/blog/1443349/201908/1443349-20190801142010057-1948821283.png)

 ### 三、虚拟机栈

#### 3.1 虚拟机栈（VM Stack)：

> 参考：https://blog.csdn.net/justry_deng/article/details/86761833

​		堆是存储的单元(堆只保存对象信息)，栈是运行时的单位;在整个JVM的内存之中，栈内存是一个非常重要的的概念；栈里面存储的都是与当前线程相关的信息，包括：局部变量、程序运行状态、方法返回地址等。

***栈内存是线程私有的，其生命周期和线程相同。***

 		栈描述的是Java方法执行的内存模型；执行一个方法时会产生一个栈帧，随后将其保存到栈(后进先出)的顶部，方法执行完毕后会自动将此方法对应的栈帧自顶部移除(即：出栈)，当前方法的栈帧必然在当前线程对应的栈的顶部。



#### 3.2 概念图：



![](D:\桌面\编程学习\Java\JVM\images\栈帧.PNG)

注：一个栈帧对应一个未运行完的函数；当某一个函数被调用一次时，就会产生一个栈帧(记录着该函数的相
       关信息)，并入栈;当该函数运行完毕之后，其对应的栈帧会出栈。

注：函数的一次调用就会产生一个对应的栈帧，而不是一个函数本身对应一个栈帧；如：递归调用就会产生
       无数个栈帧。



#### 3.3 栈帧：

##### 3.3.1 栈帧包含的数据：

![](D:\桌面\编程学习\Java\JVM\images\栈帧数据.PNG)

##### 3.3.2 局部变量表(Local Variable Table)：

局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

注：局部变量表以变量槽(solt)为最小单位，一个变量槽最大只允许保存四字节(即:32位)长度的变量。如果超过32位，则会开辟两个连续的solt。



![](D:\桌面\编程学习\Java\JVM\images\局部变量表.PNG)

##### 3.3.3  操作数栈(Operand Stack)：

表达式计算在操作数栈中完成。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。

注：在概念模型里面，虚拟机栈中的栈帧之间是完全相互独立的。但是在大多数虚拟机的实现里都会做一些优化
       处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，
       这样在进行方法的调用时就可以共用一部分数据，无需进行额外的参数复制传递，重叠的过程如图：

![](D:\桌面\编程学习\Java\JVM\images\操作数栈.png)



##### 3.3.4  返回地址(Return Adderss)：

方法执行完(不论是正常执行还是发生了异常)后需要返回到方法被调用的位置，程序才能继续执行，方法但回事可能需要在栈帧中保存一些信息，用来帮助恢复上层方法的执行状态。

注：一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而
       方法异常退出时，返回地址是要通过异常处理器表来决定的，栈帧中一般不会保存这部分信息。

注：方法的退出过程实际上就等于把当前栈帧出栈，因此退出时可能执行的操作有：

(1) 恢复上层方法的局部变量表和操作数栈。
(2) 把返回值(如果有的话)压入调用者栈帧的操作数栈中。
(3) 调整PC计数器的值以指向方法调用指令后面的一条指令。

##### 3.3.5 动态链接(Dynamic Linking)：

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

##### 3.3.6 指向运行时常量池的引用：

当前方法所属的类的运行时常量池的引用，引用其他的常量类或者使用String池中的字符串。



### 四、堆

#### 4.1 JAVA堆内存划分

![](D:\桌面\编程学习\Java\JVM\images\JVM堆内存.png)

1. JVM内存划分为堆内存和非堆内存，堆内存分为年轻代（Young Generation）、老年代（Old Generation），非堆内存就一个永久代（Permanent Generation）。
2. 年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是 8:1:1。
3. 堆内存用途：存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回收。
4. 非堆内存用途：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。

在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。
元空间有注意有两个参数：

- MetaspaceSize ：初始化元空间大小，控制发生GC阈值
- MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存

####  4.2 为什么移除永久代？

移除永久代原因：为融合HotSpot JVM与JRockit VM（新JVM技术）而做出的改变，因为JRockit没有永久代。
有了元空间就不再会出现永久代OOM问题了！

#### 4.3 分代概念

新生成的对象首先放到年轻代Eden区，当Eden空间满了，触发Minor GC，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。
老年代存储长期存活的对象，占满时会触发Major GC=Full GC，GC期间会停止所有线程等待GC完成，所以对响应要求高的应用尽量减少发生Major GC，避免响应超时。
**Minor GC ： 清理年轻代** 
**Major GC ： 清理老年代**
**Full GC ： 清理整个堆空间，包括年轻代和永久代**
所有GC都会停止应用所有线程。

**为什么分代？**

将对象根据存活概率进行分类，对存活时间长的对象，放到固定区，从而减少扫描垃圾时间及GC频率。针对分类进行不同的垃圾回收算法，对算法扬长避短。

**为什么survivor分为两块相等大小的幸存空间？**

主要为了解决碎片化。如果内存碎片化严重，也就是两个对象占用不连续的内存，已有的连续内存不够新对象存放，就会触发GC。

#### 4.4 JVM堆内存常用参数

| 参数                   | 描述                                                      |
| :--------------------- | :-------------------------------------------------------- |
| -Xms                   | 堆内存初始大小，单位m、g                                  |
| -Xmx（MaxHeapSize）    | 堆内存最大允许大小，一般不要大于物理内存的80%             |
| -XX:PermSize           | 非堆内存初始大小，一般应用设置初始化200m，最大1024m就够了 |
| -XX:MaxPermSize        | 非堆内存最大允许大小                                      |
| -XX:NewSize（-Xns）    | 年轻代内存初始大小                                        |
| -XX:MaxNewSize（-Xmn） | 年轻代内存最大允许大小，也可以缩写                        |
| -XX:SurvivorRatio=8    | 年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1    |
| -Xss                   | 堆栈内存大小                                              |



#### 4.5 堆内存分配：

**堆分为：新生代、老年代，**
**新生代又分为**：**Eden、From、To区**

**新生代:老年代=1/3:2/3 ，Eden:From:To=8:1:1**

 

![](D:\桌面\编程学习\Java\JVM\images\新老代内存.png)

　　**对象都会首先在 Eden 区域分配，当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC(年轻代GC)。**
**在GC前，对象存在于eden区和From区，在一次新生代垃圾回收后，如果对象还存活，则会进入To区，并且对象的年龄**
**还会加 1，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。经过这次GC后，Eden区和"From"区已经被清空。**
**这个时候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次GC前的“From”，新的"From"就是上次GC前的"To"。**
**不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，"To"区被填满之后，**
**会将所有对象移动到年老代中。**

***注：谁空谁是TO***  

#### 4.6 垃圾回收算法（GC，Garbage Collection）

红色是标记的非活动对象，绿色是活动对象。

- **标记-清除（Mark-Sweep）**
  GC分为两个阶段，标记和清除。首先标记所有可回收的对象，在标记完成后统一回收所有被标记的对象。同时会产生不连续的内存碎片。碎片过多会导致以后程序运行时需要分配较大对象时，无法找到足够的连续内存，而不得已再次触发GC。

![](D:\桌面\编程学习\Java\JVM\images\堆标记清除.png)

- **复制（Copy）**
  将内存按容量划分为两块，每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。这样使得每次都是对半个内存区回收，也不用考虑内存碎片问题，简单高效。缺点需要两倍的内存空间。

![](D:\桌面\编程学习\Java\JVM\images\堆标记复制.png)

- **标记-整理（Mark-Compact）**
  也分为两个阶段，首先标记可回收的对象，再将存活的对象都向一端移动，然后清理掉边界以外的内存。此方法避免标记-清除算法的碎片问题，同时也避免了复制算法的空间问题。
  一般年轻代中执行GC后，会有少量的对象存活，就会选用复制算法，只要付出少量的存活对象复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外过多内存空间分配，就需要使用标记-清理或者标记-整理算法来进行回收。

![Java堆内存又溢出了！教你一招必杀技](D:\桌面\编程学习\Java\JVM\images\堆标记整理.png)



### 五、方法区：

> 参考 ：https://blog.csdn.net/zuodaoyong/article/details/107031191

#### 5.1 概述：

Hotspot虚拟机，方法区有个别称non-heap（**非堆**），方法区可以看作是一块独立于堆的内存空间

**特点：**

+ 方法区与java堆一样，是各个线程共享的内存区域
+ 方法区在jvm启动的时候被创建，并且它的实际的物理内存空间中和java堆区一样都是可以不连续的
+ 方法区的大小，跟堆空间一样，可以选择固定大小或者扩展
+ 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误
  - java8以前（java.lang.OutOfMemoryError:PermGen space）永久代
  - java8以后（java.lang.OutOfMemoryError:Metaspace）元空间
+ 关闭jvm就会释放这个区域的内存

#### 5.2 演进过程：

jdk7以前，方法区的实现是永久代，jdk8开始方法区的实现使用元空间取代了永久代。

![img](https://img-blog.csdnimg.cn/20200703081157105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p1b2Rhb3lvbmc=,size_16,color_FFFFFF,t_70)

**元空间和永久代最大的区别是：元空间不在虚拟机设置的内存中，而是使用本地内存**



#### 5.3 方法区内部结构：

方法区存储信息主要：类型信息，域（Field）信息，方法（Method）信息，常量，静态变量，即时编译器编译后的代码缓存

**1、类型信息**

对每个加载的类型（类class、接口、枚举、注解），jvm必须在方法区存储以下类型信息

（1）类型的完整有效名称（全名=报名.类名）

（2）类型直接父类的完整有效名（接口和java.lang.Object，没有父类）

（3）类型的修饰符（public，abstract，final的某个子集）

（4）类型直接接口的一个有序列表

**2、域（Field）信息**

（1）保存类型的所有域的相关信息以及域的声明顺序

（2）域的相关信息：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient）

**3、方法（Method）信息**

jvm保存所有方法的以下信息，同域信息一样的包括声明顺序

（1）方法名称

（2）方法返回参数（或者void）

（3）方法参数的数量和类型（按顺序）

（4）方法的修饰符（public，private，protected，static，final，synchronized，native，abstract）

（5）方法的字节码，操作数栈、局部变量表及大小（abstract和native除外）

（6）异常表（abstract和native除外），每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。

**4、常量池**

一个有效的字节码文件除了包含类的版本信息，字段，方法以及接口等描述信息外，还包含一项信息那就是常量池，包含各种字面量（数量值，字符串值）和对类型（类），域和方法的符号引用。

常量池，可以看作是一个表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等类型

（1）方法区，内部包含了运行时常量池

（2）字节码文件，内部包含了常量池

字节码文件结构

![img](https://img-blog.csdnimg.cn/20200704081435391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p1b2Rhb3lvbmc=,size_16,color_FFFFFF,t_70)

**常量池的作用**

一个java源文件的类，接口，编译后产生一个字节码文件。而java中字节码需要数据支持，通常这种数据会很大以至于不能直接存储在字节码里，换一种方式，可以存储到常量池里。

**运行时常量池**

（1）运行时常量池是方法区的一部分，常量池表是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载存放到方法区的运行时常量池中。

（2）运行时常量池创建时机：在加载类和接口到虚拟机后，就会创建对应的运行时常量池

（3）jvm为每一个已加载的类型（类或者接口）都维护一个常量池，池中的数据项和数组项类似，使用索引访问

（4）运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换成真实地址

（5）运行时常量池类似于传统编程语言的符号表，但是它所包含的数据比符号表更加丰富

（6）当创建类或者接口的运行时常量池，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则jvm会抛出OutOfMemoryError异常。

（7）运行时常量池具备动态性，比如使用String类的intern方法加入运行时常量池中

#### 5.4 方法区演化进程：

![](D:\桌面\编程学习\Java\JVM\images\方法区1.png)

![](D:\桌面\编程学习\Java\JVM\images\方法区2.png)

![](D:\桌面\编程学习\Java\JVM\images\方法区3.png)

![](D:\桌面\编程学习\Java\JVM\images\方法区4.png)

**jdk8使用元空间替换jdk7及以前的永久代的目的**

（1）设置永久代空间大小，不太好确定

（2）对永久代调优比较困难



### 六、类加载

#### 6.1 类加载的过程

七个步骤：**加载->验证->准备->解析->初始化->使用->卸载**

 

![](D:\桌面\编程学习\Java\JVM\images\类加载.png)


类加载主要三步过程:**加载->连接->初始化**，而连接又包括**验证、准备、解析**三个阶段。

其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的


**准备阶段**：是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

(1)这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。

(2)这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，
那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关
键字public static final int value=111 ，那么准备阶段 value 的值就被复制为 111。

对于初始化阶段，虚拟机严格规范了有且只有**5种情况下**，必须对类进行**初始化**：

**(1)创建类的实例(new 的方式)。访问某个类或接口的静态变量，或者对该静态变量赋值，调用类的静态方法**

**(2)使用反射的方法对类进行反射调用的时候。**

**(3)当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。**

**(4)当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。**

**(5)当使用 JDK 1.7 的动态语言支持时。**

 

#### 6.2 类加载器

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部
继承自java.lang.ClassLoader。

类加载器分为：**启动类加载器、扩展类加载器、应用程序类加载器。**

 

**![img](https://img2018.cnblogs.com/blog/1443349/201908/1443349-20190801141611273-405204697.png)**

 

**(1)启动类加载器**：最顶层的加载类，负责加载 %JAVA_HOME%/jre/lib目录下rt.jar。

**(2)扩展类加载器**：主要负责加载目录 %JRE_HOME%/jre/lib/ext 目录下的jar包和类。

**(3)应用程序类加载器** :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。


#### 6.3 双亲委派模型 (双亲委派模型工作原理)：

**(1)双亲委派模型工作原理：**

　　**在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试去加载。在类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完全这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。**

**(2)双亲委派模型的好处：避免类的重复加载，也保证了 Java 的核心 API 不被篡改。**

**(3)如果我们不想用双亲委派模型怎么办？**

**为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 loadClass() 即可。**



### 七、新建对象过程

#### 7.1 堆栈和方法区的交互图：

![](D:\桌面\编程学习\Java\JVM\images\堆栈方法区交互.png)



#### 7.2 Java对象的创建过程

对象创建过程：**类加载检查、分配内存、初始化零值、设置对象头、执行init()方法。**

**(1) 类加载检查：**当虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，
并检查这个符号引用所代表的类是否已经被加载、解析和初始化过。如果没有，则执行相应的类加载过程。


**(2) 分配内存**：把一块确定大小的内存从java堆中分配出来

分配方式：**指针碰撞**和**空闲列表**

用哪种方式取决于堆的规整性，而堆的规整性又取决于采用的GC收集器算法是"标记-清除"还是"标记-整理"，
值得注意的是，复制算法内存也是规整的。


**指针碰撞**： 使用场合：堆内存规整的情况下，既没有内存碎片

原理： 将用过的内存全部移动到一端，没用过的内存移动到另一端，中间有个分界值指针，
只需要沿着没用过的内存移动指针对象即可。

GC收集器： Serial、ParNew


**空闲列表:** 使用场合：堆内存不规整

原理：虚拟机会维护一个列表，该列表会记录哪些内存是可用的，在分配的时候会找一块足够大
的内存来分配给对象，最后更新列表记录。

GC收集器：CMS收集器(concurrent mark sweep 并发标记清除算法)

**内存分配并发问题**：在创建对象的时候回遇到一个很重要的问题，就是线程安全问题

虚拟机采用两种方法保证线程安全：

**CAS+失败重试：**CAS（Compare And Swap 比较并替换）是乐观锁的一种实现方式。所谓的乐观锁就是，每次不加锁而假设没有冲突去完成某项操作，
如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS+失败重试的方式更新操作的原子性。

**TLAB:**为每一个线程预先在eden区分配一块内存，jvm在给线程中的对象分配内存时，首先在tlab分配，当对象大于 TLAB的剩余空间或TLAB的内存满了时，再采用上述的CAS进行内存分配。

**(3) 初始化零值**：将内存空间都初始化为零值，让对象的实例字段在代码中不用赋初始 值就可以直接使用。

**(4) 设置对象头**：对象头中保存着对象的哈希码、GC分代年龄、锁的状态标志等。

**(5) 执行init()方法**：执行init()方法，把对象按照程序员的意愿进行初始化。



#### 7.3 对象的访问定位(使用句柄和直接指针的方式)

创建对象就是为了使用对象，java程序通过栈上的reference数据来操作堆上的具体对象，主流的对象访问
方式有两种：**1.使用句柄 2.直接指针**

 

![img](https://img2018.cnblogs.com/blog/1443349/201908/1443349-20190801143200348-1542913907.png)


1.**使用句柄** ：如果使用句柄，那么java会在堆中开辟一块内存来当作句柄池，reference中储存着句柄的地址，
而句柄包含了对象的实例数据和对象的类型数据各个的地址信息。

 

![img](https://img2018.cnblogs.com/blog/1443349/201908/1443349-20190801143238263-2034876969.png)

 

2.**直接指针**：直接储存对象的地址。

区别：使用句柄最大的好处是reference中储存的是稳定的句柄地址，当对象被移动时只会修改句柄中的实例数据指针，而不用修改reference。使用直接指针的好处是速度快。

### 八、GC内容：

> 参考：https://www.cnblogs.com/linliquan/p/11281716.html 

#### 8.1 哪些内存需要回收？

由于程序计数器、虚拟机栈、本地方法栈的生命周期都跟随线程的生命周期，当线程销毁了，
内存也就回收了，所以这几个区域不用过多地考虑内存回收。由于堆和方法区的内存都是动态
分配的，而且是线程共享的，所以内存回收主要关注这部分区域。

#### 8.2 如何判断对象是否存活？

**(1)引用计数法：**

给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，如果引用失效，计数器值减1，
所以当该计数器的值为0时，就表示该对象可以被回收了。但是存在两个对象之间相互循环引用的问题。

**(2)可达性分析算法：**

通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索的路径称为引用链，
当一个对象到“GC Roots”没有任何引用链相连的话，也就是GC Roots到这个对象不可达时，证明此对象
已经不可用，可以被回收了。

**二次标记:**

在可达性分析算法中被判断是对象不可达时不一定会被垃圾回收机制回收，因为要真正宣告一个对象
的死亡，必须经历两次标记的过程。如果发现对象不可达时，将会进行第一次标记，此时如果该对象
调用了finalize()方法，那么这个对象会被放置在一个叫F-Queue的队列之中，如果在此队列中该对象
没有成功拯救自己（拯救自己的方法是该对象有没有被重新引用），那么GC就会对F-Queue队列中的对象
进行小规模的第二次标记，一旦被第二次标记的对象，将会被移除队列并等待被GC回收，所以finalize()
方法是对象逃脱死亡命运的最后一次机会。

**可作为 GC Roots 的对象：**

**(1)虚拟机栈(栈帧中的本地变量表)中引用的对象**
**(2)方法区中类静态属性引用的对象**
**(3)方法区中常量引用的对象**
**(4)本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象**

 #### 8.3 垃圾收集算法

**(1)标记—清除算法：**

**标记阶段：**先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象。
**清除阶段：**清除垃圾对象。

**缺点**：效率不高、会产生空间碎片。


**(2)复制算法：**将内存分为大小相同的两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。

特点：并不会产生内存碎片，但是代价是把内存缩小了一半，效率比较低。


**(3)标记-整理算法：**标记-清除算法一样，区别是清除的时候会把所有存活的对象移到一端。

(**4)分代回收算法：**根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。

**新生代**：每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。

**老年代**：老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用标记—清除算法或者标记—整理算法。



#### 8.4 垃圾回收器：

 

![img](https://img2018.cnblogs.com/blog/1443349/201908/1443349-20190801142452547-271764703.png)

 

**(1)Serial 收集器**：单线程收集器，在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。

新生代：使用复制算法。 老年代：标记整理算法。

**(2)ParNew 收集器**：可以认为是 Serial 收集器的多线程版本。

新生代：使用复制算法。 老年代：标记整理算法。

**(3)Parallel Scavenge 收集器**：这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。

**(4)Serial Old 收集器**：收集器的老年代版本，单线程，使用标记整理算法。

**(5)Parallel Old 收集器**：Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用标记整理算法。

**(6)CMS 收集器：**CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。

回收过程主要分为四个步骤：

（1）**初始标记**：标记一下GC Roots能直接关联到的对象，速度很快；
（2）**并发标记**：进行GC Roots Tracing的过程，也就是标记不可达的对象，相对耗时；
（3）**重新标记**：修正并发标记期间因用户程序继续运作导致的标记变动，速度比较快；
（4）**并发清除**：对标记的对象进行统一回收处理，比较耗时；

缺点：对 CPU 资源敏感、无法收集浮动垃圾、有大量的空间碎片

**(7)G1 收集器**：面向服务端的垃圾回收器，基于“标记-整理”算法实现。

回收过程主要分为四个步骤：

（1）**初始标记**：标记一下GC Roots能直接关联到的对象，速度很快；
（2）**并发标记**：进行GC Roots Tracing(搜索标记)的过程，也就是标记不可达的对象，相对耗时 ；
（3）**最终标记**：修正并发标记期间因用户程序继续运作导致的标记变动，速度比较快；
（4）**筛选回收**：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划；

**G1收集器的特点**
（1）**并发与并行**：机型垃圾收集时可以与用户线程并发运行；
（2）**分代收集**：能根据对象的存活时间采取不同的收集算法进行垃圾回收；
（3）**不会产生内存碎片**：基于标记——整理算法和复制算法保证不会产生内存空间碎片；
（4）**可预测的停顿**：G1除了追求低停顿时间外，还能建立可预测的停顿时间模型，便于用户的实时监控；


#### 8.5 内存分配策略：

**内存分配策略：**

**(1)对象优先在 Eden 分配**
**(2)大对象直接进入老年代**
**(3)长期存活的对象将进入老年代**
**(4)动态对象年龄判定**
**(5)空间分配担保**

**堆分为：新生代、老年代，**
**新生代又分为**：**Eden、From、To区**

**新生代:老年代=1/3:2/3 ，Eden:From:To=8:1:1**

 

![](D:\桌面\编程学习\Java\JVM\images\新老代内存.png)


　　**对象都会首先在 Eden 区域分配，当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC(年轻代GC)。**
**在GC前，对象存在于eden区和From区，在一次新生代垃圾回收后，如果对象还存活，则会进入To区，并且对象的年龄**
**还会加 1，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。经过这次GC后，Eden区和"From"区已经被清空。**
**这个时候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次GC前的“From”，新的"From"就是上次GC前的"To"。**
**不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，"To"区被填满之后，**
**会将所有对象移动到年老代中。**

#### 8.6 引用类型

**强引用**：1
**软引用**：当内存不足时，就会被回收；
**弱引用**：只要发生GC，就会被回收；
**虚引用**：随时都会被回收；





### 九、jvm的常量池

> 参考博客：https://blog.csdn.net/a1214624851/article/details/83016600
>
> 参考5.4 方法区进行理解

#### 9.1 常量池的分类：

**jvm中的常量池分为三种**

 1.类文件常量池(Class Constant Pool)

 2.运行时常量池(Runtime Constant Pool)

3.字符串常量池(String Constant Pool)



#### 9.2 类文件常量池：

##### 9.2.1概念：

​		我们写的每一个Java类被编译后，就会形成一份class文件（每个class文件都有一个class常量池）。class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。

##### 9.2.2 存放内容：

存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。

字面量包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;

符号引用包括：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符



#### 9.3 **运行时常量池**

##### 9.3.1概念：

**运行时常量池存在于内存（方法区）中**，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern()),符号引用可以被解析为直接引用。

JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。

而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，**运行时常量池也是每个类都有一个**。

在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。

 由于class文件中有一项信息是常量池，这部分内容在类加载后进入方法区的运行时常量池存放，在常量池的符号引用有一部分是会被转变为直接引用的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。



##### 9.3.2 存放内容：

class文件元信息描述，编译后的代码数据，引用类型数据，类文件常量池



#### 9.4 **字符串常量池**

##### 9.4.1 概念：

在HotSpot VM里实现的string pool功能的是一个StringTable类，它**是一个哈希表**，默认值大小长度是**1009**。

这个StringTable在每个HotSpot VM的**实例只有一份**，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。

##### 9.4.2 存放内容：

在JDK6.0及之前版本中，String Pool里放的都是字符串常量；

  在JDK7.0中，由于String#intern()发生了改变，因此String Pool中也可以存放放于堆内的字符串对象的引用。



#### 9.5 案例分析：

![](D:\桌面\编程学习\Java\JAVASE\images\字符常量池.png)

- tr1==str2 指向同**1**个堆对象，同时创建了一个常量池引用。
- str3 创建了**3**个堆对象，只创建了一个常量池引用。
- str4 创建了**2**个堆对象，其中有个对象的value引用另一个的value地址，并未创建常量池引用。



**另外补充几点关于String的总结：**

- 字面量方式声明，查找常量池有则返回引用。否则，**堆里生成对象**，同时在在常量池生成引用。如：String s = "xyz";

- 字面量相+，根据+的结果查找常量池有则返回引用，否则，堆里生成对象，同时在常量池生成引用。如：String s = "a"+"b"; 常量池查找“ab”。最多生成**三个**对象。

- 字符串相+，如果有一个不是字面量，则必在堆里生成**一个**新对象，常量池不生成引用。如：String s=s1+"a";

