# JAVA 多线程

> 参考微博：https://www.cnblogs.com/wugongzi/p/11491965.html
>
> ​					https://www.jianshu.com/p/28387056eeb4

### 一、进程和线程的概念与区别

#### 1.1 进程和线程的概念。

（1）进程是计算机中因运行程序的实体。

进程是程序的真正运行，用户下达运行程序的命令后，就会产生进程。同一程序可产生  多个进程。

进程有三种基本状态：运行状态、就绪状态、阻塞状态。

（2）线程是程序执行流 的最小单位。一般由线程ID，当前指令指针，寄存器集合和堆栈组成。线程是进程的一个实体，是系统独立调度和分派的基本单位，线程和同它在一个进程下的线程共享内存（但每个线程有自己独立的栈，堆是所有线程共享的）。

 

#### 1.2 线程与进程的区别？

（1）调度：在传统操作系统中，拥有资源和独立调度的基本单位都是进程。引入线程之后，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程的切换，而不同进程中进行的线程切换，则会引起进程切换。

（2）拥有资源：进程是拥有资源的基本单位，线程不会拥有资源，但线程可以共享其隶属于进程的共享资源。

（3）并发性：进程可以并发执行，而且同一进程内的多个线程也可以并发执行，从而使操作系统具有良好的并发性，大大提高了系统吞吐量。

（4）系统开销：创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备。在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时，只需保存和设置少量的寄存器内容。同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现。

（5）地址空间和其他资源：进程的地址空间之间互相独立，同一进程的各个线程间共享进程的资源，某进程内的线程对于其他进程不可见。

（6）通信方面：进程间通信需要借助操作系统，而线程间可以直接读/写进程数据段来进行通信。



**●** **典型的调度算法包括**：先来先服务（FIFS）、短作业优先算法（SJF）、

优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。

**●** **死锁产生的原因和必要条件。**

原因： （1）系统资源的竞争。

​    （2）进程推进顺序非法。

必要4大条件：

​    **（1）互斥条件。**

​    **（2）不剥夺条件。**

​    **（3）请求和保持条件。**

​    **（4）循环等待条件。**

​    银行家算法是著名的死锁避免算法。

**●** **常用的置换算法有**：最佳置换算法（OPT）、先进先出页面置换算法（FIFO）、最近最久未使用（LRU）置换算法。 

#### 1.3 多线程的五种状态：

1.Running: 接受新task, 处理等待的task;

2.ShutDown: 不接受新task,但处理等待的task;

3.Stop: 不接受新task, 不处理等待的task, 尝试打断正在执行的task;

4.Tidying:但所有task都被终止, worCount == 0的时候(workCount是指有效的线程数);

5.Terminated: 执行完terminated()方法;

-------

Running -> ShutDown:

　　执行shutdown();

Running or ShutDown --> Stop:

　　执行shutdownNow();

 

Stop --> Tidying

　　当pool为空时

ShutDown --> Tidying

　　当queue 和 pool都为空时

 

Tidying --> Terminated

　　当terminated()方法结束时;

### 二、JAVA锁

> 参考博客：https://www.cnblogs.com/jyroy/p/11365935.html

![](D:\桌面\编程学习\Java\JAVASE\images\锁.png)

#### 2.1 乐观锁VS悲观锁

##### 2.1.1 概念：

- **悲观锁：**对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。

​       ***悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。***



- **乐观锁：**认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。

  ***乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。***



##### 2.1.2 调用比较：

![](D:\桌面\编程学习\Java\JAVASE\images\悲乐观锁调用.png)



#### 2.2 自旋锁 VS 适应性自旋锁

![](D:\桌面\编程学习\Java\JAVASE\images\自旋锁.png)

##### 2.2.1 自旋介绍：

​		在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

​		而为了让当前线程“稍等一下”，我们需让当前线程进行**自旋**，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

​		**自适应**意味着自旋的**时间（次数）不再固定**，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock



### 2.3 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁

​		**synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”**

-----

***目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。***

-----

![](D:\桌面\编程学习\Java\JAVASE\images\对象头锁.png)

##### 2.3.1 无锁：

概念：**无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。**

无锁的特点就是**修改**操作在**循环内**进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。

##### 2.3.2 偏向锁：

**偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。**

在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

**偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，**线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。



##### 2.3.3 轻量级锁

**是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。**

如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

**若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。**



##### 2.3.4 重量级锁：

升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

整体的锁状态升级流程如下：

![](D:\桌面\编程学习\Java\JAVASE\images\锁升级过程.png)

----

*综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。*



#### 2.4 公平锁 VS 非公平锁

##### 2.4.1 概念：

**公平锁**是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

**非公平锁**是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。



**ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。**



#### 2.5 可重入锁 VS 非可重入锁

##### 2.5.1 概念：

**可重入锁**（ReentrantLock和synchronized）又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。

**非可重入锁**（NonReentrantLock）的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。

（就是假设线程中的两个同步方法，一个线程中的同步方法1得到了锁，执行完了但锁未释放，需要等待线程结束释放锁，但是此时进入另一个同步方法2，需要锁，但是锁被方法1占着，导致方法2执行不了）



#### 2.6 独享锁 VS 共享锁

##### 2.6.1 概念：

**独享锁**也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。

**共享锁**是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。



##### 2.6.2  ReentrantReadWriteLock

**ReentrantReadWriteLock**有两把锁：**ReadLock和WriteLock**，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。

在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。